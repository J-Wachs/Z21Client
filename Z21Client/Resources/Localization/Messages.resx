<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Text0001" xml:space="preserve">
    <value>Subscribing to AllLocoInfoReceived event. Adding AllLocoInfo broadcast flag.</value>
  </data>
  <data name="Text0002" xml:space="preserve">
    <value>Unsubscribing from AllLocoInfoReceived event. Removing AllLocoInfo broadcast flag.</value>
  </data>
  <data name="Text0003" xml:space="preserve">
    <value>Subscribing to RailComDataReceived event. Adding AllRailCom broadcast flag and starting polling.</value>
  </data>
  <data name="Text0004" xml:space="preserve">
    <value>Unsubscribing from RailComDataReceived event. Removing AllRailCom broadcast flag and stopping polling.</value>
  </data>
  <data name="Text0005" xml:space="preserve">
    <value>Subscribing to RBusDataReceived event. Adding RBus broadcast flag.</value>
  </data>
  <data name="Text0006" xml:space="preserve">
    <value>Unsubscribing from RBusDataReceived event. Removing RBus broadcast flag.</value>
  </data>
  <data name="Text0007" xml:space="preserve">
    <value>Subscribing to SystemStateChanged event. Adding SystemState broadcast flag.</value>
  </data>
  <data name="Text0008" xml:space="preserve">
    <value>Unsubscribing from SystemStateChanged event. Removing SystemState broadcast flag.</value>
  </data>
  <data name="Text0009" xml:space="preserve">
    <value>Connecting to Z21 at {Host}:{Port}...</value>
  </data>
  <data name="Text0010" xml:space="preserve">
    <value>Already connected. Please disconnect first.</value>
  </data>
  <data name="Text0011" xml:space="preserve">
    <value>Connection failed: Host {Host} is not reachable (ping failed).</value>
  </data>
  <data name="Text0012" xml:space="preserve">
    <value>Invalid IP address provided: {Host}</value>
  </data>
  <data name="Text0013" xml:space="preserve">
    <value>UdpClient created and bound to listen on local port {Port}</value>
  </data>
  <data name="Text0014" xml:space="preserve">
    <value>Failed to create and bind UdpClient on port {Port}. The port may already be in use by another application.</value>
  </data>
  <data name="Text0015" xml:space="preserve">
    <value>Connection failed: Host responded to ping, but did not respond to Z21 command (handshake failed).</value>
  </data>
  <data name="Text0016" xml:space="preserve">
    <value>Z21 client connection verified and fully started.</value>
  </data>
  <data name="Text0017" xml:space="preserve">
    <value>Disconnecting from Z21...</value>
  </data>
  <data name="Text0018" xml:space="preserve">
    <value>Receive task was successfully cancelled as expected during disconnect.</value>
  </data>
  <data name="Text0019" xml:space="preserve">
    <value>Receive task did not cancel within the expected time during disconnect.</value>
  </data>
  <data name="Text0020" xml:space="preserve">
    <value>Disconnected.</value>
  </data>
  <data name="Text0021" xml:space="preserve">
    <value>GetLocoInfoAsync: Requested loco info for address {Address}</value>
  </data>
  <data name="Text0022" xml:space="preserve">
    <value>GetLocoModeAsync: Requested loco mode for address {Address}</value>
  </data>
  <data name="Text0023" xml:space="preserve">
    <value>GetRailComDataAsync: Requested RailCom info for loco {locoAddress}</value>
  </data>
  <data name="Text0024" xml:space="preserve">
    <value>GetRBusDataAsync: Requested R-Bus data for group index {groupIndex}</value>
  </data>
  <data name="Text0025" xml:space="preserve">
    <value>GetSerialtNumberAsync: Requested z21/Z21 serial number</value>
  </data>
  <data name="Text0026" xml:space="preserve">
    <value>GetSystemStateAsync: Requested system state</value>
  </data>
  <data name="Text0027" xml:space="preserve">
    <value>GetTurnoutModeAsync: Requested turnout mode for address {address}</value>
  </data>
  <data name="Text0028" xml:space="preserve">
    <value>GetZ21CodeAsync: Requested z21/Z21 (feature) code</value>
  </data>
  <data name="Text0029" xml:space="preserve">
    <value>Set loco drive for address {Address}: Speed={Speed}, rocoValue={rocoValue} NativeSteps={NativeSpeedSteps}, Direction={Direction}</value>
  </data>
  <data name="Text0030" xml:space="preserve">
    <value>Toggle function {functionIndex} for loco address {address}</value>
  </data>
  <data name="Text0031" xml:space="preserve">
    <value>Setting loco mode for address {Address} to {Mode}</value>
  </data>
  <data name="Text0032" xml:space="preserve">
    <value>Sending Emergency Stop command.</value>
  </data>
  <data name="Text0033" xml:space="preserve">
    <value>Setting turnout mode for address {Address} to {Mode}</value>
  </data>
  <data name="Text0034" xml:space="preserve">
    <value>Setting turnout position address {address}, position {position}</value>
  </data>
  <data name="Text0035" xml:space="preserve">
    <value>Setting track power off</value>
  </data>
  <data name="Text0036" xml:space="preserve">
    <value>Setting track power on</value>
  </data>
  <data name="Text0037" xml:space="preserve">
    <value>An exception occurred during ping to {Host}.</value>
  </data>
  <data name="Text0038" xml:space="preserve">
    <value>Sending keep-alive message to Z21.</value>
  </data>
  <data name="Text0039" xml:space="preserve">
    <value>Requesting RailCom data from next locomotive in ring buffer</value>
  </data>
  <data name="Text0040" xml:space="preserve">
    <value>Connection to Z21 lost. No response to multiple pings.</value>
  </data>
  <data name="Text0041" xml:space="preserve">
    <value>No message received from Z21 for a while. Pinging to check connection...</value>
  </data>
  <data name="Text0042" xml:space="preserve">
    <value>Ping successful, Z21 is still on the network. Waiting for data.</value>
  </data>
  <data name="Text0043" xml:space="preserve">
    <value>Ping failed. Failure count: {Count}</value>
  </data>
  <data name="Text0044" xml:space="preserve">
    <value>An exception occurred during watchdog ping. Failure count: {Count}</value>
  </data>
  <data name="Text0045" xml:space="preserve">
    <value>Cannot send command. Client is not connected.</value>
  </data>
  <data name="Text0046" xml:space="preserve">
    <value>Failed to send command to central station. Exception: {message}</value>
  </data>
  <data name="Text0047" xml:space="preserve">
    <value>An error occurred in the receive loop. Exception: {message}</value>
  </data>
  <data name="Text0048" xml:space="preserve">
    <value>Received malformed data: not enough bytes to read message length. Remaining bytes: {Length}</value>
  </data>
  <data name="Text0049" xml:space="preserve">
    <value>Encountered zero-length message in data stream. Stopping parse of this packet.</value>
  </data>
  <data name="Text0050" xml:space="preserve">
    <value>Received malformed data: buffer is smaller than the indicated message length. Expected: {Expected}, Actual remaining: {Actual}</value>
  </data>
  <data name="Text0051" xml:space="preserve">
    <value>Received an unhandled or malformed packet. Header: 0x{Header:X4}, Length: {Length}</value>
  </data>
  <data name="Text0052" xml:space="preserve">
    <value>Received Loco Slot Info packet is too short. Expected at least 24 bytes, got {Length}</value>
  </data>
  <data name="Text0053" xml:space="preserve">
    <value>Loco Slot Info for slot {SlotNumber} received: Address={Address}</value>
  </data>
  <data name="Text0054" xml:space="preserve">
    <value>Send an unknown X-Bus command to Z21</value>
  </data>
  <data name="Text0055" xml:space="preserve">
    <value>Received an unhandled X-Bus command with X-Header: 0x{XHeader:X2}</value>
  </data>
  <data name="Text0056" xml:space="preserve">
    <value>RailCom data for loco {Address} received.</value>
  </data>
  <data name="Text0057" xml:space="preserve">
    <value>Z21 Code received: {LockState}</value>
  </data>
  <data name="Text0058" xml:space="preserve">
    <value>R-Bus data for group {GroupIndex} received.</value>
  </data>
  <data name="Text0059" xml:space="preserve">
    <value>Turnout Mode for address {Address} received: {Mode}</value>
  </data>
  <data name="Text0060" xml:space="preserve">
    <value>Received Emergency stop packet is too short. Expected 7 bytes, got {Length}</value>
  </data>
  <data name="Text0061" xml:space="preserve">
    <value>Received Emergency stop packet with invalid checksum. Received: 0x{Received:X2}, Calculated: 0x{Calculated:X2}. Packet discarded.</value>
  </data>
  <data name="Text0062" xml:space="preserve">
    <value>Emergency stop received</value>
  </data>
  <data name="Text0063" xml:space="preserve">
    <value>Received Turnout Info packet is too short. Expected 9 bytes, got {Length}</value>
  </data>
  <data name="Text0064" xml:space="preserve">
    <value>Received Turnout Info packet with invalid checksum. Received: 0x{Received:X2}, Calculated: 0x{Calculated:X2}. Packet discarded.</value>
  </data>
  <data name="Text0065" xml:space="preserve">
    <value>Turnout Info for address {Address} received: {State}</value>
  </data>
  <data name="Text0066" xml:space="preserve">
    <value>Received Track Power Info packet is too short. Expected 7 bytes, got {Length}</value>
  </data>
  <data name="Text0067" xml:space="preserve">
    <value>Received Track Power Info packet with invalid checksum. Received: 0x{Received:X2}, Calculated: 0x{Calculated:X2}. Packet discarded.</value>
  </data>
  <data name="Text0068" xml:space="preserve">
    <value>Track Power State received: {trackPowerInfo}</value>
  </data>
  <data name="Text0069" xml:space="preserve">
    <value>Serial Number received: {SerialNumber}</value>
  </data>
  <data name="Text0070" xml:space="preserve">
    <value>Hardware Info received: {HWType}, Firmware: {FWVersion}</value>
  </data>
  <data name="Text0071" xml:space="preserve">
    <value>Failed to parse firmware version from LAN_GET_HWINFO response.</value>
  </data>
  <data name="Text0072" xml:space="preserve">
    <value>Firmware bug workaround: Combined LocoInfo and LocoMode for address {Address} and raised event.</value>
  </data>
  <data name="Text0073" xml:space="preserve">
    <value>Loco Mode for address {Address} received: {Mode}</value>
  </data>
  <data name="Text0074" xml:space="preserve">
    <value>Broadcast flags received and processed. Flags: 0x{Flags:X8}</value>
  </data>
  <data name="Text0075" xml:space="preserve">
    <value>Received Loco Info packet is too short. Expected at least {Length} bytes, got {ActualLength}</value>
  </data>
  <data name="Text0076" xml:space="preserve">
    <value>Received Loco Info packet with invalid checksum. Received: 0x{Received:X2}, Calculated: 0x{Calculated:X2}. Packet discarded.</value>
  </data>
  <data name="Text0077" xml:space="preserve">
    <value>Firmware bug workaround: Stored partial LocoInfo for address {Address}, awaiting LocoMode.</value>
  </data>
  <data name="Text0078" xml:space="preserve">
    <value>Loco Info for address {Address} received and processed.</value>
  </data>
  <data name="Text0079" xml:space="preserve">
    <value>Firmware version received and processed: {Version}</value>
  </data>
  <data name="Text0080" xml:space="preserve">
    <value>Failed to parse firmware version from received data.</value>
  </data>
  <data name="Text0081" xml:space="preserve">
    <value>System state packet is too short. Expected at least 18 bytes, got {Length}</value>
  </data>
  <data name="Text0082" xml:space="preserve">
    <value>System state received and successfully processed. Internal voltage: {volt} mV.</value>
  </data>
  <data name="Text0083" xml:space="preserve">
    <value>Setting broadcast flags to {subscripedBroadcastFlags}</value>
  </data>
  <data name="Text0084" xml:space="preserve">
    <value>GetLocoSlotInfoAsync: Requested loco info for slot {slotNumber}</value>
  </data>
  <data name="Text0085" xml:space="preserve">
    <value>GetBroadcastFlagsAsync: Requested the broadcast flags</value>
  </data>
  <data name="Text0086" xml:space="preserve">
    <value>GetFirmwareVersionAsync: Requested the firmware version</value>
  </data>
  <data name="Text0087" xml:space="preserve">
    <value>GetHardwareInfoAsync: Requested the hardware information</value>
  </data>
</root>